<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · WaspNet</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">WaspNet</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../example/">Example</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Neurons-1"><span>Neurons</span></a></li><li><a class="tocitem" href="#Layers-1"><span>Layers</span></a></li><li><a class="tocitem" href="#Networks-1"><span>Networks</span></a></li><li><a class="tocitem" href="#Simulations-1"><span>Simulations</span></a></li><li><a class="tocitem" href="#Utilities-1"><span>Utilities</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com//blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference-1"><a class="docs-heading-anchor" href="#Reference-1">Reference</a><a class="docs-heading-anchor-permalink" href="#Reference-1" title="Permalink"></a></h1><h2 id="Neurons-1"><a class="docs-heading-anchor" href="#Neurons-1">Neurons</a><a class="docs-heading-anchor-permalink" href="#Neurons-1" title="Permalink"></a></h2><h3 id="LIF-1"><a class="docs-heading-anchor" href="#LIF-1">LIF</a><a class="docs-heading-anchor-permalink" href="#LIF-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="WaspNet.LIF" href="#WaspNet.LIF"><code>WaspNet.LIF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LIF{T&lt;:Number}&lt;:AbstractNeuron</code></pre><p>Contains the necessary parameters for describing a Leaky Integrate-and-Fire (LIF) neuron as well as the current membrane potential of the neuron.</p><p><strong>Fields</strong></p><ul><li><code>τ::T</code>: Neuron time constant (ms)</li><li><code>R::T</code>: Neuronal model resistor (kOhms)</li><li><code>θ::T</code>: Threshold voltage (mV)</li><li><code>I::T</code>: Background current injection (mV)</li><li><code>v0::T</code>: Reset voltage (mV)</li><li><code>state::T</code>: Current membrane potential (mV)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaspNet.update-Tuple{WaspNet.LIF,Any,Any,Any}" href="#WaspNet.update-Tuple{WaspNet.LIF,Any,Any,Any}"><code>WaspNet.update</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update!(neuron::LIF, input_update, dt, t)</code></pre><p>Evolve and <code>LIF</code> neuron subject to a membrane potential step of size <code>input_update</code> a time duration <code>dt</code> starting from time <code>t</code></p></div></section></article><h3 id="Izh-1"><a class="docs-heading-anchor" href="#Izh-1">Izh</a><a class="docs-heading-anchor-permalink" href="#Izh-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="WaspNet.Izh" href="#WaspNet.Izh"><code>WaspNet.Izh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Izh{T&lt;:Number}&lt;:AbstractNeuronn</code></pre><p>Contains the vector of paramters [a, b, c, d, I, θ] necessary to simulate an Izhikevich neuron as well as the current state of the neuron.</p><p>The @with_kw macro is used to produce a constructor which accepts keyword arguments for all values. This neuron struct is immutable, therefor we store the state of the neuron in an <code>Array</code> such that its values can change while the parameters remain static. This represents a minimal example for an <code>AbstractNeuron</code> implementation to build it into a <code>Layer</code>.</p><p><strong>Fields</strong></p><ul><li><code>a::T</code>-<code>d::T</code>: Neuron parameters as described at https://www.izhikevich.org/publications/spikes.htm</li><li><code>I::T</code>: Background current (mA)</li><li><code>θ::T</code>: Threshold potential (mV)</li><li><code>v0::T</code>: Reset voltage (mV)</li><li><code>u0::T</code>: Reset recovery variable value</li><li><code>state::T</code>: Vector holding the current (v,u) state of the neuron</li><li><code>output::T</code>: Vector holding the current output of the neuron</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaspNet.update-Tuple{WaspNet.Izh,Any,Any,Any}" href="#WaspNet.update-Tuple{WaspNet.Izh,Any,Any,Any}"><code>WaspNet.update</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update(neuron::Izh, input_update, dt, t)</code></pre><p>Evolves the given <code>Neuron</code> subject to an input of <code>input_update</code> a time duration <code>dt</code> starting from time <code>t</code> according to the equations defined in the Izhikevich paper https://www.izhikevich.org/publications/spikes.htm</p><p>We use an Euler update for solving the set of differential equations for its computational efficiency and simplicity of implementation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="WaspNet.reset-Tuple{WaspNet.Izh}" href="#WaspNet.reset-Tuple{WaspNet.Izh}"><code>WaspNet.reset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reset(neuron::Izh)</code></pre><p>Resets the state of the Izhikevich neuron to its initial values given by <code>v0</code>, <code>u0</code></p></div></section></article><h3 id="Functional-Neurons-1"><a class="docs-heading-anchor" href="#Functional-Neurons-1">Functional Neurons</a><a class="docs-heading-anchor-permalink" href="#Functional-Neurons-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="WaspNet.Functional" href="#WaspNet.Functional"><code>WaspNet.Functional</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Functional{T&lt;:Number, F&lt;:Function}&lt;:AbstractNeuron</code></pre><p>A neuron type which applies some scalar function to its input and returns that value as both its state and output.</p><p><strong>Fields</strong></p><ul><li><code>func::F</code>: A scalar function to apply to all inputs</li><li><code>state::T</code>: The last value computed by this neuron&#39;s function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L8">source</a></section></article><h2 id="Layers-1"><a class="docs-heading-anchor" href="#Layers-1">Layers</a><a class="docs-heading-anchor-permalink" href="#Layers-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="WaspNet.Layer" href="#WaspNet.Layer"><code>WaspNet.Layer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Layer{
    L&lt;:AbstractNeuron, N&lt;:Number, A&lt;:AbstractArray{N,1}, M&lt;:Union{AbstractArray{N,2}, Array{AbstractArray{N,2},1}
    }&lt;:AbstractLayer</code></pre><p>Track a population of neurons of one <code>AbstractNeuron</code> type, the other <code>Layer</code>s those neurons are connected to, and the incoming weights. </p><p><strong>Fields</strong></p><ul><li><code>neurons::Array{L,1}</code>: an array of neurons for the <code>Layer</code></li><li><code>W&lt;:Union{Matrix,AbstractBlockArray}</code>: either a Matrix or BlockArray containing weights for inputs from incoming layers</li><li><code>conns</code>: either <code>[]</code> or <code>Array{Int,1}</code> indicating which <code>Layer</code>s in the <code>Network</code> are connected as inputs to this <code>Layer</code></li><li><code>input::Array{N,1}</code>: a pre-allocated array of zeros for staging inputs to the layer</li><li><code>output::Array{N,1}</code>: a pre-allocated array for staging outputs from this layer</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="WaspNet.Layer" href="#WaspNet.Layer"><code>WaspNet.Layer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Layer(neurons, W[, conns = Array{Int,1}()])</code></pre><p>Constructs a <code>Layer</code> with constituent <code>neurons</code> which accept inputs from the <code>Layer</code>s denoted by <code>conns</code> (input 1 is the <code>Network</code> input) and either a <code>BlockArray</code> of weights if <code>length(conns) &gt; 1</code> or a Matrix of weights otherwise.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="WaspNet.Layer-Union{Tuple{M}, Tuple{A}, Tuple{N}, Tuple{L}, Tuple{J}, Tuple{Array{L,1},M,Array{J,1},Int64,A,A}} where M&lt;:Union{AbstractArray{N,2}, Array{#s59,1} where #s59&lt;:AbstractArray{N,2}} where A&lt;:AbstractArray{N,1} where N&lt;:Number where L&lt;:AbstractNeuron where J" href="#WaspNet.Layer-Union{Tuple{M}, Tuple{A}, Tuple{N}, Tuple{L}, Tuple{J}, Tuple{Array{L,1},M,Array{J,1},Int64,A,A}} where M&lt;:Union{AbstractArray{N,2}, Array{#s59,1} where #s59&lt;:AbstractArray{N,2}} where A&lt;:AbstractArray{N,1} where N&lt;:Number where L&lt;:AbstractNeuron where J"><code>WaspNet.Layer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Layer(neurons, W, conns, N_neurons, input, output)</code></pre><p>Default non-parametric constructor for <code>Layer</code>s for pre-processing inputs and computing parametric types.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="WaspNet.reset!-Tuple{AbstractLayer}" href="#WaspNet.reset!-Tuple{AbstractLayer}"><code>WaspNet.reset!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reset!(l::AbstractLayer)</code></pre><p>Reset all of the neurons in <code>l</code> to the state defined by their <code>reset!</code> function.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="WaspNet.update!-Union{Tuple{M}, Tuple{A}, Tuple{N}, Tuple{L}, Tuple{Layer{L,N,A,M},Any,Any,Any}} where M&lt;:(AbstractArray{#s55,1} where #s55&lt;:AbstractArray) where A where N where L" href="#WaspNet.update!-Union{Tuple{M}, Tuple{A}, Tuple{N}, Tuple{L}, Tuple{Layer{L,N,A,M},Any,Any,Any}} where M&lt;:(AbstractArray{#s55,1} where #s55&lt;:AbstractArray) where A where N where L"><code>WaspNet.update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function update!(l::Layer{L,N,A,M}, input, dt, t) where {L,N,A, M&lt;:AbstractArray{T,1}}</code></pre><p>Evolve the state of all of the neurons in the <code>Layer</code> a duration <code>dt</code>, starting from time <code>t</code>, subject to a set of inputs from all <code>Network</code> layers in <code>input</code>. </p><p>Not all arrays within <code>input</code> are used; we iterate over <code>l.conn</code> to select the appropriate inputs to this <code>Layer</code>, and the corresponding <code>Block</code>s from <code>l.W</code> are used to calculate the net <code>Layer</code> input.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="WaspNet.update!-Union{Tuple{M}, Tuple{A}, Tuple{N}, Tuple{L}, Tuple{Layer{L,N,A,M},Any,Any,Any}} where M&lt;:AbstractArray{N,2} where A where N where L" href="#WaspNet.update!-Union{Tuple{M}, Tuple{A}, Tuple{N}, Tuple{L}, Tuple{Layer{L,N,A,M},Any,Any,Any}} where M&lt;:AbstractArray{N,2} where A where N where L"><code>WaspNet.update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function update!(l::Layer, input, dt, t)</code></pre><p>Evolve the state of all of the neurons in the <code>Layer</code> a duration <code>dt</code>, starting from time <code>t</code>, subject to a set of inputs from all <code>Network</code> layers in <code>input</code>.</p><p>This (default) method assumes a feed-forward, non-BlockArray representation for <code>l.W</code></p><p><strong>Arguments</strong></p><ul><li><code>l::Layer</code>: the <code>Layer</code> to be evolved</li><li><code>input</code>: an <code>Array</code> of <code>Array</code>s of output values from other <code>Layers</code> potentially being input to <code>l</code></li><li><code>dt</code>: the time step to evolve the <code>Layer</code></li><li><code>t</code>: the time at the start of the current time step</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="WaspNet.update!-Union{Tuple{M}, Tuple{A}, Tuple{N}, Tuple{L}, Tuple{Layer{L,N,A,M},Any,Any,Any}} where M&lt;:BlockArrays.AbstractBlockArray where A where N where L" href="#WaspNet.update!-Union{Tuple{M}, Tuple{A}, Tuple{N}, Tuple{L}, Tuple{Layer{L,N,A,M},Any,Any,Any}} where M&lt;:BlockArrays.AbstractBlockArray where A where N where L"><code>WaspNet.update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function update!(l::Layer{L,N,A,M}, input, dt, t)</code></pre><p>Evolve the state of all of the neurons in the <code>Layer</code> a duration <code>dt</code>, starting from time <code>t</code>, subject to a set of inputs from all <code>Network</code> layers in <code>input</code>. </p><p>Not all arrays within <code>input</code> are used; we iterate over <code>l.conn</code> to select the appropriate inputs to this <code>Layer</code>, and the corresponding <code>Block</code>s from <code>l.W</code> are used to calculate the net <code>Layer</code> input.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="WaspNet.get_neuron_count-Tuple{AbstractLayer}" href="#WaspNet.get_neuron_count-Tuple{AbstractLayer}"><code>WaspNet.get_neuron_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_neuron_count(l::AbstractLayer)</code></pre><p>Return the number of neurons in the given <code>Layer</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="WaspNet.get_neuron_outputs-Tuple{AbstractLayer}" href="#WaspNet.get_neuron_outputs-Tuple{AbstractLayer}"><code>WaspNet.get_neuron_outputs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_neuron_outputs(l::AbstractLayer)</code></pre><p>Return the current output of <code>l</code>&#39;s constituent neurons </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="WaspNet.get_neuron_states-Tuple{AbstractLayer}" href="#WaspNet.get_neuron_states-Tuple{AbstractLayer}"><code>WaspNet.get_neuron_states</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_neuron_states(l::AbstractLayer)</code></pre><p>Return the current state of <code>l</code>&#39;s constituent neurons</p></div></section></article><h2 id="Networks-1"><a class="docs-heading-anchor" href="#Networks-1">Networks</a><a class="docs-heading-anchor-permalink" href="#Networks-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="WaspNet.Network" href="#WaspNet.Network"><code>WaspNet.Network</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct Network&lt;:AbstractNetwork</code></pre><p>Contains constituent <code>Layer</code>s, orchestrates the movement of signals between <code>Layer</code>s, and handles first-layer input.</p><p><strong>Fields</strong></p><ul><li><code>layers::Array{AbstractLayer,1}</code>: Array of <code>Layer</code>s ordered from 1 to N for N layers</li><li><code>N_in::Int</code>: Number of input dimensions to the first <code>Layer</code></li><li><code>prev_outputs::Vector</code>: Vector of vectors sized to hold the output from each <code>Layer</code> </li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="WaspNet.Network-Tuple{Any,Int64}" href="#WaspNet.Network-Tuple{Any,Int64}"><code>WaspNet.Network</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function Network(layers, N_in::Int)</code></pre><p>Given an array of <code>Layer</code>s and the dimensionality of the input to the network, make a new <code>Network</code> which is a copy of each <code>Layer</code> with weights converted to <code>BlockArray</code> format.</p><p>The output dimensionality is in </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="WaspNet.Network-Union{Tuple{Array{L,1}}, Tuple{L}} where L&lt;:AbstractLayer" href="#WaspNet.Network-Union{Tuple{Array{L,1}}, Tuple{L}} where L&lt;:AbstractLayer"><code>WaspNet.Network</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function Network(layers::Array{L, 1}) where L &lt;: AbstractLayer</code></pre><p>Given an array of <code>Layer</code>s, constructs the <code>Network</code> resulting from connecting the <code>Layer</code>s with their specified <code>conn</code>s. </p><p>The input dimensionality is inferred from the size of the weight matrices for the first <code>Layer</code> in the <code>layers</code> array.</p></div></section></article><h2 id="Simulations-1"><a class="docs-heading-anchor" href="#Simulations-1">Simulations</a><a class="docs-heading-anchor-permalink" href="#Simulations-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="WaspNet.SimulationResult" href="#WaspNet.SimulationResult"><code>WaspNet.SimulationResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SimulationResult{
    OT&lt;:AbstractArray{&lt;:Number,2}, ST&lt;:AbstractArray{&lt;:Number, 2}, TT&lt;:AbstractArray{&lt;:Real,1}
    }&lt;:AbstractSimulation</code></pre><p>Contains simulation results from simulating a <code>Network</code> for a specific length of time with <code>simulate!</code></p><p><strong>Fields</strong></p><ul><li><code>outputs::OT</code>: A <code>Matrix</code> containing the output of all simulated neurons at every time step.</li><li><code>states::ST</code>: A <code>Matrix</code> containing the state of all simulated neurons at every time step. If states were not tracked, an Nx0 dimensional <code>Matrix</code>.</li><li><code>times::TT</code>: An <code>Array</code> of times at which the <code>WaspnetElement</code> was sampled.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="WaspNet.SimulationResult-Union{Tuple{TT}, Tuple{EL}, Tuple{EL,TT}} where TT&lt;:(AbstractArray{#s59,1} where #s59&lt;:Real) where EL&lt;:WaspnetElement" href="#WaspNet.SimulationResult-Union{Tuple{TT}, Tuple{EL}, Tuple{EL,TT}} where TT&lt;:(AbstractArray{#s59,1} where #s59&lt;:Real) where EL&lt;:WaspnetElement"><code>WaspNet.SimulationResult</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SimulationResult(element::EL, times::TT) where {EL&lt;:WaspnetElement,TT&lt;:AbstractArray{&lt;:Real, 1}}</code></pre><p>Given a <code>WaspnetElement</code> and the times at which to simulate the element, construct the <code>SimulationResult</code> instance to store the results of the simulation. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="WaspNet.simulate!" href="#WaspNet.simulate!"><code>WaspNet.simulate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">simulate!(element::WaspnetElement, input::Matrix, dt, tf, t0 = 0.; track_state=false, kwargs...)</code></pre><p>Simulates the supplied <code>WaspnetElement</code> subject to some pre-sampled <code>input</code> where each column is one time step and returns the relevant <code>SimulationResult</code> instance</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="WaspNet.simulate!" href="#WaspNet.simulate!"><code>WaspNet.simulate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">simulate!(element::WaspnetElement, input::Function, dt, tf, t0 = 0.; track_state=false, kwargs...)</code></pre><p>Simulates the supplied <code>WaspnetElement</code> subject to a function of time, <code>input</code> by sampling <code>input</code> at the chosen sample times and returns the relevant <code>SimulationResult</code> instance</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="WaspNet.sim_update!-Tuple{WaspnetElement,Any,Any,Any}" href="#WaspNet.sim_update!-Tuple{WaspnetElement,Any,Any,Any}"><code>WaspNet.sim_update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sim_update!(ne::WaspnetElement, input_update, dt, t)</code></pre><p>Generic function for wrapping calls to <code>update!</code> from <code>simulate!</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="WaspNet.sim_update!-Union{Tuple{N}, Tuple{T}, Tuple{AbstractNeuron,AbstractArray{T,N},Any,Any}} where N where T&lt;:Number" href="#WaspNet.sim_update!-Union{Tuple{N}, Tuple{T}, Tuple{AbstractNeuron,AbstractArray{T,N},Any,Any}} where N where T&lt;:Number"><code>WaspNet.sim_update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sim_update!(neuron::AbstractNeuron, input_update&lt;:AbstractArray{T,N}, dt, t) where {T&lt;:Number, N}</code></pre><p>Wrapper to ensure that if a 1D array is passed to update a neuron, it is converted to a scalar first</p></div></section></article><h2 id="Utilities-1"><a class="docs-heading-anchor" href="#Utilities-1">Utilities</a><a class="docs-heading-anchor-permalink" href="#Utilities-1" title="Permalink"></a></h2><h3 id="General-Utilities-1"><a class="docs-heading-anchor" href="#General-Utilities-1">General Utilities</a><a class="docs-heading-anchor-permalink" href="#General-Utilities-1" title="Permalink"></a></h3><h3 id="Pruning-1"><a class="docs-heading-anchor" href="#Pruning-1">Pruning</a><a class="docs-heading-anchor-permalink" href="#Pruning-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="WaspNet.delete_entries-Tuple{Any,Any}" href="#WaspNet.delete_entries-Tuple{Any,Any}"><code>WaspNet.delete_entries</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function delete_entries(W, entries; axis::Int = 1)</code></pre><p>Given an <code>AbstractArray</code>, deletes the specified <code>entries</code> (e.g. rows or columns) along the given axis; used for pruning weight matrices. </p><p>As an example, <code>delete_entries(W, [3,4]; axis = 2)</code> would delete columns 3 and 4 from <code>W</code> and return the modified <code>W</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="WaspNet.prune-Tuple{WaspnetElement,Any,Any}" href="#WaspNet.prune-Tuple{WaspnetElement,Any,Any}"><code>WaspNet.prune</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function prune(el::WaspnetElement, layers, neurons[, l_idx])</code></pre><p>Given an element <code>el</code> along with indices for target <code>Neuron</code>s, constructs new <code>Layer</code>s and <code>Network</code>s with all references to those neurons removed by deleting rows and columns from the proper weight matrices in each <code>Layer</code>.</p><p><code>layers</code> should be an array of indices relative to the <code>Network</code> it is being pruned in; <code>neurons</code> should be an array of arrays of indices where the entries in each inner array are indices of neurons within the respective <code>Layer</code> from <code>layers</code>.</p><p><strong>Arguments</strong></p><ul><li><code>el::WaspnetElement</code>: The element to prune neurons from, either a <code>Network</code> or <code>Layer</code></li><li><code>layers</code>: A list of indices for which <code>Layer</code>s we&#39;re removing neurons from the <code>Network</code> where it resides</li><li><code>neurons</code>: A list of lists of neurons to remove in the respective entries from <code>layers</code>.</li><li><code>l_idx</code>: If <code>prune</code> is called on a <code>Layer</code>, <code>l_idx</code> denotes the index of the that <code>Layer</code> if it were to appear in the list <code>layers</code></li></ul></div></section></article><p>&lt;!– &quot;src/utilities/pruning.jl&quot; –&gt;</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../example/">« Example</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 30 July 2020 23:33">Thursday 30 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
